# Rust 编程练习案例

## 案例 1: 异步 HTTP 请求

**需求**：
编写一个异步程序，使用 `reqwest` 库异步地请求多个 URL，并输出每个 URL 的响应状态码。

**提示**：
- 使用 `reqwest` 库来发送 HTTP 请求。
- 使用 `tokio` 作为异步运行时。
- 使用 `async` 和 `await` 关键字处理异步操作。

## 案例 2: 异步任务超时

**需求**：
编写一个异步程序，启动一个异步任务，该任务模拟一个耗时的操作（例如 5 秒），并在超时时（例如 2 秒）停止该任务。

**提示**：
- 使用 `tokio::time::timeout` 函数来处理超时。
- 创建一个异步函数来模拟耗时操作。

## 案例 3: 多线程数据共享

**需求**：
编写一个多线程程序，使用 `Arc` 和 `Mutex` 来共享一个计数器。启动多个线程，每个线程将计数器的值加 1，然后输出最终的计数器值。

**提示**：
- 使用 `std::sync::Arc` 和 `std::sync::Mutex` 来共享数据。
- 使用 `std::thread` 创建线程。
- 确保线程安全地操作共享数据。

## 案例 4: 异步和多线程混合

**需求**：
编写一个程序，启动多个线程，每个线程内部运行一个异步任务。每个异步任务模拟一些 I/O 操作，并输出结果。主线程等待所有线程完成。

**提示**：
- 使用 `tokio` 的异步功能来模拟 I/O 操作。
- 使用 `std::thread` 启动线程，并在每个线程中使用 `tokio::runtime::Runtime` 来运行异步任务。

## 案例 5: 异步工作池

**需求**：
创建一个异步工作池，其中多个异步任务在指定的工作池中并发执行。每个任务模拟一些计算密集型操作，并输出其执行结果。主程序等待所有任务完成并汇总结果。

**提示**：
- 使用 `tokio::task::spawn` 启动并发任务。
- 使用 `futures::future::join_all` 或类似方法等待所有任务完成。

## 实现提示

- **案例 1**：你需要添加 `reqwest` 作为依赖，并确保你处理了异步 I/O 操作和错误处理。

  ```toml
  [dependencies]
  reqwest = { version = "0.11", features = ["json"] }
  tokio = { version = "1", features = ["full"] }

- **案例 2**：使用 tokio::time::sleep 来模拟耗时操作，并用 timeout 处理超时。

- **案例 3**：使用 Arc<Mutex<T>> 来共享和保护数据，创建多个线程，并使用 Mutex 来保证线程安全。

- **案例 4**：在每个线程内创建一个新的 tokio::runtime::Runtime 来运行异步任务，主线程使用 join 等待所有线程完成。

- **案例 5**：创建一个异步工作池，并使用 join_all 等待所有任务完成，可以使用 tokio::task::spawn 来并发运行任务。
